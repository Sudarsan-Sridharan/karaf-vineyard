/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.karaf.vineyard.registry.storage;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.karaf.vineyard.common.DataFormat;
import org.apache.karaf.vineyard.common.Endpoint;
import org.apache.karaf.vineyard.common.Environment;
import org.apache.karaf.vineyard.common.Maintainer;
import org.apache.karaf.vineyard.common.Role;
import org.apache.karaf.vineyard.common.Service;
import org.apache.karaf.vineyard.common.ServiceOnEnvironment;
import org.apache.karaf.vineyard.registry.api.RegistryService;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implementation of the service processing, storing the services into a database.
 */
@Component(
        name = "org.apache.karaf.vineyard.registry.storage.sqlService",
        immediate = true
)
public class SqlRegistryService implements RegistryService {

    private final static Logger LOGGER = LoggerFactory.getLogger(SqlRegistryService.class);

    //TODO private final static String createTableQueryGenericTemplate = "";
    //TODO private final static String createTableQueryMySQLTemplate = "";
    
    private final static String DATABASE_SCHEMA = "VINEYARD";
    
    private final static String[] createTableQueryDerbyTemplate = new String[] {
        "CREATE SCHEMA " + DATABASE_SCHEMA,
        
        "CREATE TABLE " + DATABASE_SCHEMA + ".ENVIRONMENT(id SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY " 
                + " CONSTRAINT ENVIRONMENT_PK PRIMARY KEY, name VARCHAR(200) NOT NULL, description VARCHAR(8192), "
                + " scope VARCHAR(200))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".MAINTAINER(name VARCHAR(200) CONSTRAINT MAINTAINER_PK PRIMARY KEY, "
                + " email VARCHAR(200), team VARCHAR(200))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".DATAFORMAT(id SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY "
                + " CONSTRAINT DATAFORMAT_PK PRIMARY KEY, name VARCHAR(200) NOT NULL, sample VARCHAR(8192), " 
                + " dataschema VARCHAR(8192))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".ENDPOINT(location VARCHAR(200) NOT NULL CONSTRAINT ENDPOINT_PK PRIMARY KEY, "
                + " eptinput SMALLINT, eptoutput SMALLINT, "
                + " CONSTRAINT ENDPT_INPUT_DTFM_FK FOREIGN KEY (eptinput) REFERENCES " + DATABASE_SCHEMA + ".DATAFORMAT (id),"
                + " CONSTRAINT ENDPT_OUTPUT_DTFM_FK FOREIGN KEY (eptoutput) REFERENCES " + DATABASE_SCHEMA + ".DATAFORMAT (id))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".SERVICE(id SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY "
                + " CONSTRAINT SERVICE_PK PRIMARY KEY, name VARCHAR(200) NOT NULL, description VARCHAR(8192))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".X_ENV_MNT(id_environment SMALLINT, name_maintainer VARCHAR(200), "
                + " role VARCHAR(200), "
                + " CONSTRAINT X_ENV_MNT_PK PRIMARY KEY (id_environment, name_maintainer), "
                + " CONSTRAINT X_ENV_MNT_ENV_FK FOREIGN KEY (id_environment) REFERENCES " + DATABASE_SCHEMA + ".ENVIRONMENT (id), "
                + " CONSTRAINT X_ENV_MNT_MNT_FK FOREIGN KEY (name_maintainer) REFERENCES " + DATABASE_SCHEMA + ".MAINTAINER (name))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".X_SRV_ENV(id_service SMALLINT, id_environment SMALLINT, "
                + " state VARCHAR(200), version VARCHAR(50), endpoint VARCHAR(200), gateway VARCHAR(200), "
                + " CONSTRAINT X_SRV_ENV_PK PRIMARY KEY (id_service, id_environment),"
                + " CONSTRAINT X_SRV_ENV_SRV_FK FOREIGN KEY (id_service) REFERENCES " + DATABASE_SCHEMA + ".SERVICE (id), "
                + " CONSTRAINT X_SRV_ENV_ENV_FK FOREIGN KEY (id_environment) REFERENCES " + DATABASE_SCHEMA + ".ENVIRONMENT (id), "
                + " CONSTRAINT X_SRV_ENV_ENDPT_FK FOREIGN KEY (endpoint) REFERENCES " + DATABASE_SCHEMA + ".ENDPOINT (location), "
                + " CONSTRAINT X_SRV_ENV_GTW_FK FOREIGN KEY (gateway) REFERENCES " + DATABASE_SCHEMA + ".ENDPOINT (location))",
                
        "CREATE TABLE " + DATABASE_SCHEMA + ".X_SRV_ENV_META(id_service SMALLINT, id_environment SMALLINT, "
                + " metakey VARCHAR(200), metavalue VARCHAR(200), "
                + " CONSTRAINT X_SRV_ENV_META_PK PRIMARY KEY (id_service, id_environment),"
                + " CONSTRAINT X_SRV_ENV_META_FK FOREIGN KEY (id_service, id_environment) "
                + " REFERENCES " + DATABASE_SCHEMA + ".X_SRV_ENV (id_service, id_environment))"
        };
    
    /** Select queries */
    private final static String selectEnvironmentSql = 
            "select id, name, description, scope "
            + "from " + DATABASE_SCHEMA + ".ENVIRONMENT";
    private final static String selectMaintainerSql = 
            "select name, email, team "
            + "from " + DATABASE_SCHEMA + ".MAINTAINER";
    private final static String selectDataformatSql = 
            "select id, name, sample, dataschema "
            + "from " + DATABASE_SCHEMA + ".DATAFORMAT";
    private final static String selectEndpointSql = 
            "select location, eptinput, eptoutput "
            + "from " + DATABASE_SCHEMA + ".ENDPOINT";
    private final static String selectServiceSql = 
            "select id, name, description "
            + "from " + DATABASE_SCHEMA + ".SERVICE";
    private final static String selectMaintainerForEnvironmentSql =
            "select m.name name, m.email email, m.team team, x.role role "
            + "from " + DATABASE_SCHEMA + ".MAINTAINER m, " + DATABASE_SCHEMA + ".X_ENV_MNT x "
            + "where x.name_maintainer = m.name "
            + "and x.id_environment = ?";
    private final static String selectEnvironmentForServiceSql = 
            "select e.id id, x.state, x.version version, x.endpoint endpoint, x.gateway gateway"
            + "from " + DATABASE_SCHEMA + ".ENVIRONMENT e, " + DATABASE_SCHEMA + ".X_SRV_ENV x "
            + "where e.id = x.id_environment "
            + "and x.id_service = ?";
    private final static String selectMetadataEnvironmentForServiceSql = 
            "select id_service, id_environment, metakey, metavalue "
            + "from " + DATABASE_SCHEMA + ".X_SRV_ENV_META "
            + "where id_environment = ? "
            + " and id_service = ?";
    
    /** Insert queries */
    private final static String insertEnvironmentSql = 
            "insert into " + DATABASE_SCHEMA + ".ENVIRONMENT "
            + "(name, description, scope) "
            + "values (?, ?, ?)";
    private final static String insertMaintainerSql = 
            "insert into " + DATABASE_SCHEMA + ".MAINTAINER "
            + "(name, email, team) "
            + "values (?, ?, ?)";
    private final static String insertDataformatSql = 
            "insert into " + DATABASE_SCHEMA + ".DATAFORMAT "
            + "(name, sample, dataschema) "
            + "values (?, ?, ?)";
    private final static String insertEndpointSql = 
            "insert into " + DATABASE_SCHEMA + ".ENDPOINT "
            + "(location, eptinput, eptoutput) "
            + "values (?, ?, ?)";
    private final static String insertServiceSql = 
            "insert into " + DATABASE_SCHEMA + ".SERVICE "
            + "(name, description) "
            + "values (?, ?)";
    private final static String insertMaintainerForEnvironmentSql = 
            "insert into " + DATABASE_SCHEMA + ".X_ENV_MNT "
            + "(id_environment, name_maintainer, role) values (?, ?, ?)";
    private final static String insertEnvironmentForServiceSql = 
            "insert into " + DATABASE_SCHEMA + ".X_SRV_ENV "
            + "(id_service, id_environment, state, version, endpoint, gateway) "
            + "values (?, ?, ?, ?, ?, ?)";
    private final static String insertMetadataEnvironmentForServiceSql = 
            "insert into " + DATABASE_SCHEMA + ".X_SRV_ENV_META "
            + "(id_service, id_environment, metakey, metavalue) "
            + "values (?, ?, ?, ?)";
    
    /** Update queries */
    private final static String updateEnvironmentSql = 
            "update " + DATABASE_SCHEMA + ".ENVIRONMENT "
            + "set name = ?, description = ?, scope = ? "
            + "where id = ?";
    private final static String updateMaintainerSql = 
            "update " + DATABASE_SCHEMA + ".MAINTAINER "
            + "set email = ?, team = ? "
            + "where name = ?";
    private final static String updateDataformatSql = 
            "update " + DATABASE_SCHEMA + ".DATAFORMAT "
            + "set name = ?, sample = ?, dataschema = ? "
            + "where id = ?";
    private final static String updateEndpointSql = 
            "update " + DATABASE_SCHEMA + ".ENDPOINT "
            + "set eptinput = ?, eptoutput = ? "
            + "where location = ?";
    private final static String updateServiceSql = 
            "update " + DATABASE_SCHEMA + ".SERVICE "
            + "set name = ?, description = ? "
            + "where id = ?";
    
    /** Delete queries */
    private final static String deleteEnvironmentSql = 
            "delete from " + DATABASE_SCHEMA + ".ENVIRONMENT "
            + "where id = ?";
    private final static String deleteMaintainerSql = 
            "delete from " + DATABASE_SCHEMA + ".MAINTAINER "
            + "where name = ?";
    private final static String deleteDataformatSql = 
            "delete from " + DATABASE_SCHEMA + ".DATAFORMAT "
            + "where id = ?";
    private final static String deleteEndpointSql = 
            "delete from " + DATABASE_SCHEMA + ".ENDPOINT "
            + "where location = ?";
    private final static String deleteServiceSql = 
            "delete from " + DATABASE_SCHEMA + ".SERVICE "
            + "where id = ?";
    private final static String deleteMaintainerForEnvironmentSql = 
            "delete from " + DATABASE_SCHEMA + ".X_ENV_MNT ";
    private final static String deleteEnvironmentForServiceSql = 
            "delete from " + DATABASE_SCHEMA + ".X_SRV_ENV ";
    private final static String deleteMetadataEnvironmentForServiceSql = 
            "delete from " + DATABASE_SCHEMA + ".X_SRV_ENV_META ";
            
    @Reference(target = "(osgi.jndi.service.name=jdbc/vineyard)")
    private DataSource dataSource;

    private String dialect;

    @Activate
    public void activate(ComponentContext context) {
        open(context.getProperties());
    }
    
    public void open(Dictionary<String, Object> config) {
        this.dialect = getValue(config, "dialect", "derby");
        LOGGER.debug("Dialect {} ", this.dialect);
        LOGGER.debug("Datasource {} ", this.dataSource);
        try (Connection connection = dataSource.getConnection()) {
            createTables(connection);
        } catch (Exception e) {
            LOGGER.error("Error creating table ", e);
        }
    }

    private String getValue(Dictionary<String, Object> config, String key, String defaultValue) {
        String value = (String) config.get(key);
        return (value != null) ? value : defaultValue;
    }

    private void createTables(Connection connection) {

        DatabaseMetaData dbm;
        ResultSet tables;
        
        try {
            dbm = connection.getMetaData();
            
            tables = dbm.getTables(null, "VINEYARD", "SERVICE", null);
            if (!tables.next()) {
                LOGGER.info("Tables does not exist");
                // Tables does not exist so we create all the tables
                String[] createTemplate = null;
                if (dialect.equalsIgnoreCase("mysql")) {
                    //TODO createTableQueryMySQLTemplate;
                } else if (dialect.equalsIgnoreCase("derby")) {
                    createTemplate = createTableQueryDerbyTemplate;
                } else {
                    //TODO createTableQueryGenericTemplate;
                }
                try (Statement createStatement = connection.createStatement()) {
                    for (int cpt = 0; cpt < createTemplate.length; cpt++) {
                        createStatement.addBatch(createTemplate[cpt]);
                    }
                    if (createStatement.executeBatch().length == 0) {
                        throw new SQLException("No table has been created !");
                    }
                    LOGGER.info("Schema and tables has been created");
                } catch (SQLException exception) {
                    LOGGER.error("Can't create tables", exception);
                }
            } else {
                LOGGER.info("Tables already exist");
            }
        } catch (SQLException exception) {
            LOGGER.error("Can't verify tables existence", exception);
        }
    }

    @Override
    public void add(Service service) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertServiceSql, PreparedStatement.RETURN_GENERATED_KEYS)) {
                    // set values
                    insertStatement.setString(1, service.getName());
                    insertStatement.setString(2, service.getDescription());
                    insertStatement.executeUpdate();
                    
                    int newId = 0;
                    ResultSet rs = insertStatement.getGeneratedKeys();
                    
                    if (rs.next()) {
                        newId = rs.getInt(1);
                    }
                    
                    connection.commit();
                    
                    service.setId(String.valueOf(newId));
                    LOGGER.debug("Service created with id = {}", newId);
            
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't insert service with name {}", service.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public void delete(Service service) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(deleteServiceSql)) {
                    // where values
                    deleteStatement.setString(1, service.getId());
                    deleteStatement.executeUpdate();
                    deleteExtraDataForService(connection, service);
                    connection.commit();
                    LOGGER.debug("Service deleted with id = {}", service.getId());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete service with name {}", service.getId(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public void delete(String id) {
        Service service = get(id);
        if (service != null) {
            delete(service);
        }
    }
    
    private void deleteExtraDataForService(Connection connection, Service service) throws SQLException {
        String sqlQuery = deleteMetadataEnvironmentForServiceSql + " where id_service = ?";
        
        try (PreparedStatement deleteStatement = connection.prepareStatement(sqlQuery)) {
            // where values
            deleteStatement.setString(1, service.getId());
            deleteStatement.executeUpdate();
            
            LOGGER.debug("Service updated with id = {}", service.getId());
        } catch (SQLException exception) {
            LOGGER.error("Can't udpate service with name {}", service.getName(), exception);
            throw exception;
        }
        
        sqlQuery = deleteEnvironmentForServiceSql + " where id_service = ?";
        
        try (PreparedStatement deleteStatement = connection.prepareStatement(sqlQuery)) {
            // where values
            deleteStatement.setString(1, service.getId());
            deleteStatement.executeUpdate();
            
            LOGGER.debug("Service updated with id = {}", service.getId());
        } catch (SQLException exception) {
            LOGGER.error("Can't udpate service with name {}", service.getName(), exception);
            throw exception;
        }
    }

    @Override
    public void update(Service service) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement updateStatement = 
                    connection.prepareStatement(updateServiceSql)) {
                    // set values
                    updateStatement.setString(1, service.getName());
                    updateStatement.setString(2, service.getDescription());
                    // where values
                    updateStatement.setString(3, service.getId());
                    updateStatement.executeUpdate();
                    
                    updateExtraDataForService(connection, service);
                    connection.commit();
                    LOGGER.debug("Service updated with id = {}", service.getId());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't udpate service with name {}", service.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }
    
    private void updateExtraDataForService(Connection connection, Service service) throws SQLException {
        
        deleteExtraDataForService(connection, service);
        
        for (ServiceOnEnvironment srvOnEnv : service.getEnvironments()) {
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertEnvironmentForServiceSql)) {
                // set values
                insertStatement.setString(1, service.getId());
                insertStatement.setString(2, srvOnEnv.getEnvironment().getId());
                insertStatement.setString(3, srvOnEnv.getState());
                insertStatement.setString(4, srvOnEnv.getVersion());
                insertStatement.setString(5, srvOnEnv.getEndpoint().getLocation());
                insertStatement.setString(6, srvOnEnv.getGateway().getLocation());
                insertStatement.executeUpdate();
                
                LOGGER.debug("Service updated with id = {}", service.getId());
            } catch (SQLException exception) {
                LOGGER.error("Can't udpate service with name {}", service.getName(), exception);
                throw exception;
            }
            
            for (String metadataKey : srvOnEnv.getMetadata().keySet()) {
                try (PreparedStatement insertStatement = 
                        connection.prepareStatement(insertMetadataEnvironmentForServiceSql)) {
                    // set values
                    insertStatement.setString(1, service.getId());
                    insertStatement.setString(2, srvOnEnv.getEnvironment().getId());
                    insertStatement.setString(3, metadataKey);
                    insertStatement.setString(4, srvOnEnv.getMetadata().get(metadataKey));
                    insertStatement.executeUpdate();
                    
                    LOGGER.debug("Service updated with id = {}", service.getId());
                } catch (SQLException exception) {
                    LOGGER.error("Can't udpate service with name {}", service.getName(), exception);
                    throw exception;
                }
            }
        }
    }

    @Override
    public Service get(String id) {
        
        Service service = null;
        try (Connection connection = dataSource.getConnection()) {
            
            String sqlQuery = selectServiceSql + " where id = ?";
            try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
                selectStatement.setString(1, id);
                ResultSet rs = selectStatement.executeQuery();
                
                if (rs.next()) {
                    service = new Service();
                    service.setId(rs.getString("id"));
                    service.setName(rs.getString("name"));
                    service.setDescription(rs.getString("description"));
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't find service with id {}", id, exception);
            }
            
            sqlQuery = selectEnvironmentForServiceSql;
            try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
                selectStatement.setString(1, id);
                ResultSet rs = selectStatement.executeQuery();
                
                if (rs.getFetchSize() > 0) {
                    service.setEnvironments(new ArrayList<>());
                    if (rs.next()) {
                        Environment environment = selectEnvironment(connection, rs.getString("id"));
                        
                        if (environment != null) {
                            ServiceOnEnvironment srvOnEnv = new ServiceOnEnvironment();
                            srvOnEnv.setEnvironment(environment);
                            srvOnEnv.setState(rs.getString("state"));
                            srvOnEnv.setVersion(rs.getString("version"));
                            srvOnEnv.setEndpoint(selectEndpoint(connection, rs.getString("endpoint")));
                            srvOnEnv.setGateway(selectEndpoint(connection, rs.getString("gateway")));
                            srvOnEnv.setMetadata(selectMetadata(connection, environment.getId(), id));
                            // TODO populate maintainers srvOnEnv.maintainers
                            // TODO populate policies srvOnEnv.policies
                            service.getEnvironments().add(srvOnEnv);
                        }
                    }
                }
        
            } catch (SQLException exception) {
                LOGGER.error("Can't find service with id {}", id, exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return service;
    }
    
    private Map<String, String> selectMetadata(Connection connection, String idEnvironment, String idService) {
        
        try (PreparedStatement selectStatement = 
                connection.prepareStatement(selectMetadataEnvironmentForServiceSql)) {
            selectStatement.setString(1, idEnvironment);
            selectStatement.setString(2, idService);
            ResultSet rs = selectStatement.executeQuery();
            
            if (rs.getFetchSize() > 0) {
                Map<String, String> metadatas = new HashMap<>();
                while (rs.next()) {
                    metadatas.put(rs.getString("key"),rs.getString("key"));
                }
                return metadatas;
            }
        } catch (SQLException exception) {
            LOGGER.error("Can't find metadata for service with id {}", idService, exception);
        }
        return null;
    }
    
    @Override
    public List<Service> getAll() {
        
        List<Service> services = new ArrayList<>();
        
        try (Connection connection = dataSource.getConnection()) {
            
            try (PreparedStatement selectStatement = connection.prepareStatement(selectServiceSql)) {
                    ResultSet rs = selectStatement.executeQuery();
                    
                    while (rs.next()) {
                        Service service = new Service();
                        service.setId(rs.getString("id"));
                        service.setName(rs.getString("name"));
                        service.setDescription(rs.getString("description"));
                        services.add(service);
                        // TODO get extra content
                    }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't retreive the services", exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return services;
    }

    @Override
    public void addEnvironment(Environment environment) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertEnvironmentSql, PreparedStatement.RETURN_GENERATED_KEYS)) {
                // set values
                insertStatement.setString(1, environment.getName());
                insertStatement.setString(2, environment.getDescription());
                insertStatement.setString(3, environment.getScope());
                insertStatement.executeUpdate();
                
                int newId = 0;
                ResultSet rs = insertStatement.getGeneratedKeys();
                
                if (rs.next()) {
                    newId = rs.getInt(1);
                }
                
                connection.commit();
                
                environment.setId(String.valueOf(newId));
                LOGGER.debug("Environment created with id = {}", newId);
            
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't insert environment with name {}", environment.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public void deleteEnvironment(Environment environment) {
        deleteEnvironment(environment.getId());
    }

    @Override
    public void deleteEnvironment(String id) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            String sqlQuery = deleteMetadataEnvironmentForServiceSql + 
                    "where id_environment = ?";
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(sqlQuery)) {
                // where values
                deleteStatement.setString(1, id);
                deleteStatement.executeUpdate();
                
                LOGGER.debug("Environment deleted with id = {}", id);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete environment with name {}", id, exception);
                throw exception;
            }
            
            sqlQuery = deleteEnvironmentForServiceSql + 
                    "where id_environment = ?";
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(sqlQuery)) {
                // where values
                deleteStatement.setString(1, id);
                deleteStatement.executeUpdate();
                
                LOGGER.debug("Environment deleted with id = {}", id);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete environment with name {}", id, exception);
                throw exception;
            }
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(deleteEnvironmentSql)) {
                // where values
                deleteStatement.setString(1, id);
                deleteStatement.executeUpdate();
                
                LOGGER.debug("Environment deleted with id = {}", id);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete environment with name {}", id, exception);
                throw exception;
            }
            
            connection.commit();
            
        } catch (Exception exception) {
            LOGGER.error("Error when deleting environment", exception);
        }
    }

    @Override
    public void updateEnvironment(Environment environment) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement updateStatement = 
                    connection.prepareStatement(updateEnvironmentSql)) {
                // set values
                updateStatement.setString(1, environment.getName());
                updateStatement.setString(2, environment.getDescription());
                updateStatement.setString(3, environment.getScope());
                // where values
                updateStatement.setString(4, environment.getId());
                updateStatement.executeUpdate();
                
                updateMaintainerForEnvironment(connection, environment);
                
                connection.commit();
                LOGGER.debug("Environment updated with id = {}", environment.getId());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't udpate environment with name {}", environment.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }
    
    private void updateMaintainerForEnvironment(Connection connection, Environment environment) throws SQLException {
        
        String sqlQuery = deleteMaintainerForEnvironmentSql + " where id_environment = ?";
        
        try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(sqlQuery)) {
            // where values
            deleteStatement.setString(1, environment.getId());
            deleteStatement.executeUpdate();
            
            LOGGER.debug("Environment updated with id = {}", environment.getId());
        } catch (SQLException exception) {
            LOGGER.error("Can't udpate environment with name {}", environment.getName(), exception);
            throw exception;
        }
        
        for (String maintainer : environment.getMaintainers().keySet()) {
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertMaintainerForEnvironmentSql)) {
                // set values
                insertStatement.setString(1, environment.getId());
                insertStatement.setString(2, maintainer);
                insertStatement.setString(3, environment.getMaintainers().get(maintainer).name());
                insertStatement.executeUpdate();
                
                LOGGER.debug("Environment updated with id = {}", environment.getId());
            } catch (SQLException exception) {
                LOGGER.error("Can't udpate environment with name {}", environment.getName(), exception);
                throw exception;
            }
        }
    }

    @Override
    public Environment getEnvironment(String id) {
        
        try (Connection connection = dataSource.getConnection()) {
            return selectEnvironment(connection, id);
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return null;
    }
    
    private Environment selectEnvironment(Connection connection, String id) {
        Environment environment = null;
        String sqlQuery = selectEnvironmentSql + " where id = ?";
        
        try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
                selectStatement.setString(1, id);
            ResultSet rs = selectStatement.executeQuery();
            
            if (rs.next()) {
                environment = new Environment();
                environment.setId(id);
                environment.setName(rs.getString("name"));
                environment.setDescription(rs.getString("description"));
                environment.setScope(rs.getString("scope"));
            }
        
        } catch (SQLException exception) {
            LOGGER.error("Can't find environment with id {}", id, exception);
        }
        
        if (environment != null) {
            sqlQuery = selectMaintainerForEnvironmentSql;
            try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
                selectStatement.setString(1, id);
                ResultSet rs = selectStatement.executeQuery();
                
                if (rs.getFetchSize() > 0) {
                    environment.setMaintainers(new HashMap<>());
                    if (rs.next()) {
                        Maintainer maintainer = new Maintainer();
                        maintainer.setName(rs.getString("name"));
                        maintainer.setEmail(rs.getString("email"));
                        maintainer.setTeam(rs.getString("team"));
                        environment.getMaintainers().put(maintainer.getName(), Role.valueOf(rs.getString("role")));
                    }
                }
        
            } catch (SQLException exception) {
                LOGGER.error("Can't find environment with id {}", id, exception);
            }
        }
        return environment;
    }

    @Override
    public List<Environment> getAllEnvironments() {
        List<Environment> environments = new ArrayList<>();
        
        try (Connection connection = dataSource.getConnection()) {
            
            try (PreparedStatement selectStatement = connection.prepareStatement(selectEnvironmentSql)) {
                ResultSet rs = selectStatement.executeQuery();
                
                while (rs.next()) {
                    Environment environment = new Environment();
                    environment.setId(rs.getString("id"));
                    environment.setName(rs.getString("name"));
                    environment.setDescription(rs.getString("description"));
                    environment.setScope(rs.getString("scope"));
                    environments.add(environment);
                    // TODO get extra content
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't retreive the environments", exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return environments;
    }

    @Override
    public void addMaintainer(Maintainer maintainer) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertMaintainerSql)) {
                // replace space caracters for URI encoding
                maintainer.setName(maintainer.getName().replace(" ","-"));
                // set values
                insertStatement.setString(1, maintainer.getName());
                insertStatement.setString(2, maintainer.getEmail());
                insertStatement.setString(3, maintainer.getTeam());
                insertStatement.executeUpdate();
                
                connection.commit();
                LOGGER.debug("Maintainer created with name = {}", maintainer.getName());
            
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't insert maintainer with name {}", maintainer.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public void deleteMaintainer(Maintainer maintainer) {
        deleteMaintainer(maintainer.getName());
    }

    @Override
    public void deleteMaintainer(String name) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            String sqlQuery = deleteMaintainerForEnvironmentSql + 
                    "where name_maintainer = ?";
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(sqlQuery)) {
                // where values
                deleteStatement.setString(1, name);
                deleteStatement.executeUpdate();
                
                LOGGER.debug("Maintainer deleted with name = {}", name);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete maintainer with name {}", name, exception);
                throw exception;
            }
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(deleteMaintainerSql)) {
                // where values
                deleteStatement.setString(1, name);
                deleteStatement.executeUpdate();
                
                LOGGER.debug("Maintainer deleted with name = {}", name);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete maintainer with name {}", name, exception);
                throw exception;
            }
            
            connection.commit();
            
        } catch (Exception exception) {
            LOGGER.error("Error when deleting maintainer", exception);
        }
    }

    @Override
    public void updateMaintainer(Maintainer maintainer) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement updateStatement = 
                    connection.prepareStatement(updateMaintainerSql)) {
                // set values
                updateStatement.setString(1, maintainer.getEmail());
                updateStatement.setString(2, maintainer.getTeam());
                // where values
                updateStatement.setString(3, maintainer.getName());
                updateStatement.executeUpdate();
                connection.commit();
                LOGGER.debug("Maintainer updated with name = {}", maintainer.getName());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't udpate maintainer with name {}", maintainer.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public Maintainer getMaintainer(String name) {
        try (Connection connection = dataSource.getConnection()) {
            
            String sqlQuery = selectMaintainerSql + " where name = ?";
            
            try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
                selectStatement.setString(1, name);
                ResultSet rs = selectStatement.executeQuery();
                
                if (rs.next()) {
                    Maintainer maintainer = new Maintainer();
                    maintainer.setName(name);
                    maintainer.setEmail(rs.getString("email"));
                    maintainer.setTeam(rs.getString("team"));
                    return maintainer;
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't find maintainer with name {}", name, exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return null;
    }

    @Override
    public List<Maintainer> getAllMaintainers() {
        List<Maintainer> maintainers = new ArrayList<>();
        
        try (Connection connection = dataSource.getConnection()) {
            
            try (PreparedStatement selectStatement = connection.prepareStatement(selectMaintainerSql)) {
                ResultSet rs = selectStatement.executeQuery();
                
                while (rs.next()) {
                    Maintainer maintainer = new Maintainer();
                    maintainer.setName(rs.getString("name"));
                    maintainer.setEmail(rs.getString("email"));
                    maintainer.setTeam(rs.getString("team"));
                    maintainers.add(maintainer);
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't retreive the maintainers", exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return maintainers;
    }

    @Override
    public void addDataFormat(DataFormat dataformat) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertDataformatSql, PreparedStatement.RETURN_GENERATED_KEYS)) {
                // set values
                insertStatement.setString(1, dataformat.getName());
                insertStatement.setString(2, dataformat.getSample());
                insertStatement.setString(3, dataformat.getSchema());
                insertStatement.executeUpdate();
                
                int newId = 0;
                ResultSet rs = insertStatement.getGeneratedKeys();
                
                if (rs.next()) {
                    newId = rs.getInt(1);
                }
                
                connection.commit();
                
                dataformat.setId(String.valueOf(newId));
                LOGGER.debug("Dataformat created with id = {}", newId);
            
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't insert dataformat with name {}", dataformat.getName(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }     
    }

    @Override
    public void deleteDataFormat(DataFormat dataformat) {
        deleteDataFormat(dataformat.getId());
    }

    @Override
    public void deleteDataFormat(String id) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(deleteDataformatSql)) {
                // where values
                deleteStatement.setString(1, id);
                deleteStatement.executeUpdate();
                connection.commit();
                LOGGER.debug("Dataformat deleted with id = {}", id);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete dataformat with id {}", id, exception);
                throw exception;
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error when deleting environment", exception);
        }
    }

    @Override
    public void updateDataFormat(DataFormat dataformat) {

        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement updateStatement = 
                    connection.prepareStatement(updateDataformatSql)) {
                // set values
                updateStatement.setString(1, dataformat.getName());
                updateStatement.setString(2, dataformat.getSample());
                updateStatement.setString(3, dataformat.getSchema());
                // where values
                updateStatement.setString(4, dataformat.getId());
                updateStatement.executeUpdate();
                connection.commit();
                LOGGER.debug("Dataformat updated with id = {}", dataformat.getId());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't udpate dataformat with id {}", dataformat.getId(), exception);
            }
            //TODO update extra content
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public DataFormat getDataFormat(String id) {
        try (Connection connection = dataSource.getConnection()) {
            return selectDataFormat(connection, id);
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return null;
    }
    
    private DataFormat selectDataFormat(Connection connection, String id) {
        String sqlQuery = selectDataformatSql + " where id = ?";
        
        try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
            selectStatement.setString(1, id);
            ResultSet rs = selectStatement.executeQuery();
            
            if (rs.next()) {
                DataFormat dataformat = new DataFormat();
                dataformat.setId(id);
                dataformat.setName(rs.getString("name"));
                dataformat.setSample(rs.getString("sample"));
                dataformat.setSchema(rs.getString("dataschema"));
                return dataformat;
            }
        
        } catch (SQLException exception) {
            LOGGER.error("Can't find dataformat with id {}", id, exception);
        }
        return null;
    }

    @Override
    public List<DataFormat> getAllDataFormats() {
        
        List<DataFormat> dataformats = new ArrayList<>();
        try (Connection connection = dataSource.getConnection()) {
            
            try (PreparedStatement selectStatement = connection.prepareStatement(selectDataformatSql)) {
                ResultSet rs = selectStatement.executeQuery();
                
                while (rs.next()) {
                    DataFormat dataformat = new DataFormat();
                    dataformat.setId(rs.getString("id"));
                    dataformat.setName(rs.getString("name"));
                    dataformat.setSample(rs.getString("sample"));
                    dataformat.setSchema(rs.getString("dataschema"));
                    dataformats.add(dataformat);
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't retreive the dataformats", exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return dataformats;
    }

    @Override
    public void addEndpoint(Endpoint endpoint) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement insertStatement = 
                    connection.prepareStatement(insertEndpointSql)) {
                // set values
                insertStatement.setString(1, endpoint.getLocation());
                insertStatement.setString(2, endpoint.getInput().getId());
                insertStatement.setString(3, endpoint.getOutput().getId());
                insertStatement.executeUpdate();
                connection.commit();
                
                LOGGER.debug("Endpoint created with location = {}", endpoint.getLocation());
            
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't insert endpoint with location {}", endpoint.getLocation(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
    }

    @Override
    public void deleteEndpoint(Endpoint endpoint) {
        deleteEndpoint(endpoint.getLocation());
    }

    @Override
    public void deleteEndpoint(String location) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement deleteStatement = 
                    connection.prepareStatement(deleteEndpointSql)) {
                // where values
                deleteStatement.setString(1, location);
                deleteStatement.executeUpdate();
                connection.commit();
                LOGGER.debug("Endpoint deleted with location = {}", location);
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't delete endpoint with location {}", location, exception);
                throw exception;
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error when deleting endpoint", exception);
        }
    }

    @Override
    public void updateEndpoint(Endpoint endpoint) {
        try (Connection connection = dataSource.getConnection()) {
            
            if (connection.getAutoCommit()) {
                connection.setAutoCommit(false);
            }
            
            try (PreparedStatement updateStatement = 
                    connection.prepareStatement(updateEndpointSql)) {
                // set values
                updateStatement.setString(1, endpoint.getInput().getId());
                updateStatement.setString(2, endpoint.getOutput().getId());
                // where values
                updateStatement.setString(3, endpoint.getLocation());
                updateStatement.executeUpdate();
                connection.commit();
                LOGGER.debug("Endpoint updated with location = {}", endpoint.getLocation());
            } catch (SQLException exception) {
                connection.rollback();
                LOGGER.error("Can't udpate endpoint with location {}", endpoint.getLocation(), exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        
    }

    @Override
    public Endpoint getEndpoint(String location) {
        try (Connection connection = dataSource.getConnection()) {
            return selectEndpoint(connection, location);
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return null;
    }
    
    private Endpoint selectEndpoint(Connection connection, String location) {
        String sqlQuery = selectEndpointSql + " where location = ?";
        
        try (PreparedStatement selectStatement = connection.prepareStatement(sqlQuery)) {
            selectStatement.setString(1, location);
            ResultSet rs = selectStatement.executeQuery();
            
            if (rs.next()) {
                Endpoint endpoint = new Endpoint();
                endpoint.setLocation(location);
                int inputId = rs.getInt("input");
                int outputId = rs.getInt("output");
                if (inputId != 0) {
                    endpoint.setInput(selectDataFormat(connection, String.valueOf(inputId)));
                }
                if (outputId != 0) {
                    endpoint.setOutput(selectDataFormat(connection, String.valueOf(outputId)));
                }
                return endpoint;
            }
        
        } catch (SQLException exception) {
            LOGGER.error("Can't find endpoint with id {}", location, exception);
        }
        return null;
    }

    @Override
    public List<Endpoint> getAllEndpoints() {
        List<Endpoint> endpoints = new ArrayList<>();
        
        try (Connection connection = dataSource.getConnection()) {
            
            try (PreparedStatement selectStatement = connection.prepareStatement(selectServiceSql)) {
                ResultSet rs = selectStatement.executeQuery();
                
                while (rs.next()) {
                    Endpoint endpoint = new Endpoint();
                    endpoint.setLocation(rs.getString("location"));
                    int inputId = rs.getInt("input");
                    int outputId = rs.getInt("output");
                    if (inputId != 0) {
                        endpoint.setInput(selectDataFormat(connection, String.valueOf(inputId)));
                    }
                    if (outputId != 0) {
                        endpoint.setOutput(selectDataFormat(connection, String.valueOf(outputId)));
                    }
                    endpoints.add(endpoint);
                }
            
            } catch (SQLException exception) {
                LOGGER.error("Can't retreive the services", exception);
            }
            
        } catch (Exception exception) {
            LOGGER.error("Error getting connection ", exception);
        }
        return endpoints;
    }
}
